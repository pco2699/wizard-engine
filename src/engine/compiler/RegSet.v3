// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Architecture-independent representation of a register of any register class for use in
// the macro assembler and portable parts of compilers. Kept small to keep data structures small.
type Reg(index: byte) #unboxed { }

// Describes the set of registers for a target. There must be < 256.
// By convention, register #0 is reserved for indicating an unallocated register or no register.
class RegSet(regs: Array<Reg>, names: Array<string>) {
	def length = regs.length;

	def getName(r: Reg) -> string {
		var n = names[r.index];
		if (n == null) {
			if (r.index == 0) return "unalloc";
			return "unknown";
		}
		return n;
	}
}

// Specialized roles for some registers, either in the interpreter or compiled code.
enum RegRole(changes: bool) {
	NONE		(false),	// no special role
	FUNC_ARG	(false),	// incoming function argument
	DISPATCH	(true),		// (int) dispatch table register
	IP		(true),		// (int) instruction pointer
	EIP		(false),	// (int) end instruction pointer
	CIP		(true),		// (int) current instruction pointer
	STP		(true),		// (int) side-table pointer
	INSTANCE	(false),	// instance reference
	FUNC_DECL	(false),	// (int) function declaration
	MEM0_BASE	(false),	// memory #0 base address
	VSP		(true),		// (int) value stack pointer
	VFP		(false),	// value frame pointer
	SP		(false),	// stack pointer
	FP		(false),	// frame pointer
	SCRATCH		(false),	// scratch register
	RET_ABRUPT	(false),	// return of AbruptReturn
	RUNTIME_ARG_0	(false),	// argument #1 to runtime
	RUNTIME_ARG_1	(false),	// argument #2 to runtime
	RUNTIME_ARG_2	(false),	// argument #3 to runtime
	TLS		(false),	// thread local storage
}

// Describes the register configuration for a target in terms of architectural registers.
class RegConfig(regSet: RegSet, regs: RegRoles) {
	var spcFrameSize: int;

	var vsp_offset: int;
	var vfp_offset: int;
	var eip_offset: int;
	var stp_offset: int;
	var instance_offset: int;
	var wasm_func_offset: int;
	var func_decl_offset: int;
	var mem_offset: int;
	var accessor_offset: int;

	var poolMap: PoolMap;
	var regPools: Array<RegPool32>;
}
// Describes how registers are divided into pools.
class PoolMap(regSet: RegSet, numRegPools: int) {
	def numRegs = regSet.regs.length;
	def regToPool = Array<i8>.new(numRegs);
	def kindToPool = Array<byte>.new(ValueKind.REF.tag + 1);
}
// A utility giving easy access to registers for given roles.
class RegRoles(array: Array<Reg>) {
	def func_arg = array[RegRole.FUNC_ARG.tag];
	def dispatch = array[RegRole.DISPATCH.tag];
	def ip = array[RegRole.IP.tag];
	def eip = array[RegRole.EIP.tag];
	def stp = array[RegRole.STP.tag];
	def instance = array[RegRole.INSTANCE.tag];
	def func = array[RegRole.FUNC_DECL.tag];
	def mem0 = array[RegRole.MEM0_BASE.tag];
	def vsp = array[RegRole.VSP.tag];
	def vfp = array[RegRole.VFP.tag];
	def sp = array[RegRole.SP.tag];
	def fp = array[RegRole.FP.tag];
	def scratch = array[RegRole.SCRATCH.tag];
	def ret_Abrupt = array[RegRole.RET_ABRUPT.tag];
	def runtime_arg_0 = array[RegRole.RUNTIME_ARG_0.tag];
	def runtime_arg_1 = array[RegRole.RUNTIME_ARG_1.tag];
	def runtime_arg_2 = array[RegRole.RUNTIME_ARG_2.tag];
	def tls = array[RegRole.TLS.tag];
}

// A pool of (maximum 32) registers.
class RegPool32(regs: Array<Reg>) {
	def var map: Array<u5>; // maps a {reg.index} to an index into {regs}.

	new() {
		if (regs.length > 32) System.error("RegPoolError", "maximum of 32 registers exceeded");
		var max = int.min;
		for (r in regs) if (r.index > max) max = r.index;
		map = Array<u5>.new(max + 1);
		for (i < regs.length) map[regs[i].index] = u5.!(i);
	}
}